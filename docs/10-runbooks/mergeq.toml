# Merge Queue Runbook
#
# Processes branches ready for merge.
# Handles conflicts via strategy chain: ff → rebase → agent resolve.

# ------------------------------------------------------------------------------
# Worker
# ------------------------------------------------------------------------------

[worker.mergeq]
queue = "merges"
handler = "pipeline.merge"
concurrency = 1
idle_action = "wait:30s"
wake_on = ["merge:queued"]

# ------------------------------------------------------------------------------
# Queue
# ------------------------------------------------------------------------------

[queue.merges]
order = "priority DESC, created_at ASC"
visibility_timeout = "30m"
max_retries = 2
on_exhaust = "escalate"

# ------------------------------------------------------------------------------
# Pipeline
# ------------------------------------------------------------------------------

[pipeline.merge]
inputs = ["branch", "pipeline"]

[[pipeline.merge.phase]]
name = "validate"
pre = ["branch_exists", "pipeline_complete"]
run = "git fetch origin {branch}"
next = "merge"

[[pipeline.merge.phase]]
name = "merge"
lock = "main_branch"
run = { strategy = "merge" }
next = "cleanup"
on_fail = "escalate"

[[pipeline.merge.phase]]
name = "cleanup"
run = """
git push origin main
git push origin --delete {branch}
"""
next = "complete"

[[pipeline.merge.phase]]
name = "complete"
run = """
oj queue complete merges {id}
if [ -n "{pipeline}" ]; then
    oj pipeline transition {pipeline} done
fi
"""

# ------------------------------------------------------------------------------
# Guards
# ------------------------------------------------------------------------------

[guard.branch_exists]
condition = "git ls-remote --heads origin {branch} | grep -q {branch}"
timeout = "1m"
on_timeout = "oj queue remove merges {id}"

[guard.pipeline_complete]
condition = """
[ -z "{pipeline}" ] || (
    ! oj pipeline has-session {pipeline} &&
    wok list -l plan:{pipeline} -s todo,in_progress --count | grep -q '^0$'
)
"""
timeout = "5m"
on_timeout = "oj queue requeue merges {id}"

# ------------------------------------------------------------------------------
# Strategy
# ------------------------------------------------------------------------------

[strategy.merge]
checkpoint = "git rev-parse HEAD"
on_exhaust = "escalate"

[[strategy.merge.attempt]]
name = "fast-forward"
run = "git merge --ff-only FETCH_HEAD"
timeout = "1m"

[[strategy.merge.attempt]]
name = "rebase"
run = """
git checkout -b temp-rebase FETCH_HEAD
git rebase origin/main
git checkout main
git merge --ff-only temp-rebase
git branch -d temp-rebase
"""
timeout = "5m"
rollback = "git checkout main; git branch -D temp-rebase 2>/dev/null; git reset --hard {checkpoint}"

[[strategy.merge.attempt]]
name = "agent-resolve"
run = { agent = "conflict_resolution" }
timeout = "30m"
rollback = "git merge --abort 2>/dev/null; git reset --hard {checkpoint}"

# ------------------------------------------------------------------------------
# Agent
# ------------------------------------------------------------------------------

[agent.conflict_resolution]
run = "claude --print"
prompt = """
Resolve merge conflicts for branch: {branch}

The branch has been fetched. Conflicts exist between FETCH_HEAD and main.

Steps:
1. Start the merge: git merge FETCH_HEAD
2. Resolve each conflict
3. Stage resolved files: git add <file>
4. Complete merge: git commit

Signal completion with: oj done
"""
env = { OJ_PIPELINE = "merge-{branch}", OJ_PHASE = "conflict" }
heartbeat = "output"
timeout = "30m"
idle_timeout = "3m"
on_stuck = "escalate"  # Don't restart mid-conflict resolution

# ------------------------------------------------------------------------------
# Lock
# ------------------------------------------------------------------------------

[lock.main_branch]
timeout = "30m"
heartbeat = "30s"
on_stale = ["release", "rollback", "escalate"]

# ------------------------------------------------------------------------------
# Events
# ------------------------------------------------------------------------------

[pipeline.merge.events]
on_complete = "oj emit merge:complete --branch {branch} --pipeline {pipeline}"
on_fail = "oj emit merge:fail --branch {branch} --error '{error}'"
